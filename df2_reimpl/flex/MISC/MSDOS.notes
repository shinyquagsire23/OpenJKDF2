$Header:$

Notes on Porting flex to MS-DOS
-------------------------------

[These notes were last revised 30Dec89 for flex release 2.2.]

Previous releases of flex have been successfully built using Microsoft C and
the following options: /AL, /stack:10000, -LARGE, -Ml, -Mt128, -DSYS_V

Other folks report that the following work for MSC 5.1 under DOS and OS/2:

    CFLAGS=-ALu -F 8000 -Gt16000 -Ox -DMS_DOS -DSYS_V -D__RUNTIME_YYMAXDEPTH
    LINKFLAGS=/E /FAR /PAC /NOI

Where you may want to adjust -F up in order to increase available stack
size (though it may not be necessary) and you may want to increase -Gt
to some number that puts just enought of the big data items in their own
data segments.  (The default for -Gt is items of 32k.  This is too high for
flex.)  __RUNTIME_YYMAXDEPTH is useful if you have a parse.c that's
been generated by a yacc that understands how to do this; otherwise, it's a
no-op.

Jeffrey R. Jones (jjones@angate.att.com) writes [this has been edited -vp]:

.... The port was accomplished with:

		AT&T 6312 WGS (12 Mhz AT class machine)
		Microsoft C compiler Version 5.0
		'make' utility from Aztec-C package (subset of unix-make)

The re-done makefile is included ....  Do what you wish with it.


[note that this Makefile is now slightly out of date and has not been
 tested with flex 2.2]

# This makefile is used to port the flex 2.1 build to a PC.  The compiler is
# Microsoft-C Version 5.0 while the 'make' utility came with Aztec-C, which
# is VERY compatible with Unix's make.  There are a few things that Aztec-C's
# 'make' can't do that unix does so I have made a few minor changes.
# At the least you can manually compile each file and then link.
# The linker and library utilities are alos Microsoft's.
#
# Additionally, after building with the large model, the flex.map reveals that
# code-size is less than 64K, therefore, in favor of a little more execution
# efficiency, I built with the compact model.  I've used the default compiler
# optimization (no /O switches).
#
# The linker must be told to increase the run-time stack space.  The default
# stack space is 2048.  Flexing scan.l with the default stack-space results in
# a run-time stack overflow, hence the stack was increase to 4096.
#
# NOTE: I have MKS-Toolkit's yacc and was able to use it with virtually no
# modifications to anything.  If you don't have yacc for a PC, you can try
# yaccing on a unix system and downloading the resulting files to the PC.
#
#			Jeffrey R. Jones
#			jjones@angate!att.com


# make file for "flex" tool

# @(#) $Header: Makefile,v 2.3 89/06/20 17:27:12 vern Exp $ (LBL)

# Porting considerations:
#
#    For System V Unix machines, add -DSYS_V to CFLAGS.
#    For Vax/VMS, add -DSYS_V to CFLAGS.
#    For MS-DOS, add "-DMS_DOS -DSYS_V" to CFLAGS.  Create \tmp if not present.
#         You will also want to rename flex.skel to something with a three
#         character extension, change SKELETON_FILE below appropriately,
#    For Amiga, add "-DAMIGA -DSYS_V" to CFLAGS.


# the first time around use "make first_flex"


YACC=yacc
SKELETON_DIR = c:/usr/contrib/lib
SKELETON_FILE = flex.ske
SKELFLAGS = -DDEFAULT_SKELETON_FILE=\"$(SKELETON_DIR)/$(SKELETON_FILE)\"
CFLAGS = -c -AC -DMS_DOS -DSYS_V
LDFLAGS = /noi /cp:1 /stack:4096

#this null definition prevents a returned error code
MFLAGS =

FLEX_FLAGS =
FLEX = flex
CC = cl

# redefine Aztec make's built-in rule
.c.obj:
	$(CC) $(CFLAGS) $*.c

# break obj-list into two because of 128 character command-line limit of
# Microsoft's link and lib utilities.
FLEXOBJS1 = ccl.obj dfa.obj ecs.obj gen.obj main.obj misc.obj nfa.obj parse.obj
FLEXOBJS2 = scan.obj sym.obj tblcmp.obj yylex.obj

FLEX_C_SOURCES = \
	ccl.c \
	dfa.c \
	ecs.c \
	gen.c \
	main.c \
	misc.c \
	nfa.c \
	parse.c \
	scan.c \
	sym.c \
	tblcmp.c \
	yylex.c

# lib is used to get around the 128 character command-line limit of 'link'.
flex.exe : $(FLEXOBJS1) $(FLEXOBJS2)
	lib tmplib $(FLEXOBJS1);
	link $(LDFLAGS) $(FLEXOBJS2),$*.exe,,tmplib;
	rm -f tmplib.lib

# the second 'make flex.exe' causes scan.l to be RE-flexed.  The resulting
# scan.c is different from initscan.c in that \r\n are added instead of
# just \n.  Since \r\n is DOS language and this is targetted for PCs, and
# since I don't know what would happen for all cases in DOS-land, I went
# ahead and did it.
first_flex:
	cp initscan.c scan.c
	make $(MFLAGS) flex.exe
	rm -f scan.c
	make flex.exe

parse.obj: parse.c parse.h

parse.h parse.c : parse.y
	$(YACC) -d parse.y
	@mv ytab.c parse.c
	@mv ytab.h parse.h

scan.c : scan.l
	$(FLEX) -ist $(FLEX_FLAGS) scan.l > scan.c

scan.obj : scan.c parse.h

main.obj : main.c
	$(CC) $(CFLAGS) $(SKELFLAGS) main.c

###################
#don't have, or need, anything else except maybe the 'test' rule.
#
# don't have nroff
#flex.man : flex.1
#	nroff -man flex.1 >flex.man
#
# don't have lint
#lint : $(FLEX_C_SOURCES)
#	lint $(FLEX_C_SOURCES) > flex.lint
#
#distrib :
#	mv scan.c initscan.c
#	chmod 444 initscan.c
#	$(MAKE) $(MFLAGS) clean
#
#clean :
#	rm -f core errs flex *.o parse.c *.lint parse.h flex.man tags
#
#tags :
#	ctags $(FLEX_C_SOURCES)
#
#vms :	flex.man
#	$(MAKE) $(MFLAGS) distrib
#
# break this up into multiple lines...Aztec 'make' limitation
test :
	$(FLEX) -ist $(FLEX_FLAGS) scan.l > scan.tst
	diff scan.c scan.tst
	rm -f scan.tst
